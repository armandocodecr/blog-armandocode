---
title: 'Qu√© son las promesas en JavaScript, y c√≥mo se utilizan'
date: '2023-01-29'
imgTitle: 'javascript.png'
description: 'Las promesas son objetos sumamente utilizados por distintas razones, y saber c√≥mo se utilizan es vital. Conoce m√°s a detalle sobre estas en este post. üëÄ' 
readingTime: '4:00 min'
---

Las promesas en JavaScript son objetos que representan el resultado de una operaci√≥n as√≠ncrona. Una promesa puede estar en uno de tres estados: pendiente, resuelta o rechazada. Las promesas permiten manejar de manera m√°s clara y organizada la l√≥gica de nuestro c√≥digo cuando trabajamos con operaciones as√≠ncronas.

Cu√°ndo usar promesas:

1. Al realizar llamados a una API externa
2. Al leer o escribir en archivos
3. Al realizar operaciones de base de datos


Ejemplo de una promesa en JavaScript: üëá

```js
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data fetched');
    }, 1000);
  });
};

fetchData()
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

En este ejemplo, creamos una funci√≥n **fetchData** que devuelve una promesa. La promesa se resuelve despu√©s de 1 segundo con el mensaje **"Data fetched"**. 
Luego, usamos el m√©todo `then` para manejar el caso exitoso y el m√©todo `catch` para manejar errores. üë®‚Äçüíª

Los objetos Promise en JavaScript tienen los siguientes m√©todos:

1. `then`: Este m√©todo recibe dos callbacks como argumentos, uno que se ejecutar√° si la promesa se resuelve correctamente, y otro que se ejecutar√° si la promesa es rechazada.

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('La promesa se ha resuelto');
  }, 1000);
});

promise
  .then(result => {
    console.log(result); // 'La promesa se ha resuelto'
  })
  .catch(error => {
    console.error(error);
  });
```

2. `catch`: Este m√©todo recibe un callback como argumento que se ejecutar√° si la promesa es rechazada. Es equivalente a llamar a `then`(null, callback).

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('La promesa ha fallado'));
  }, 1000);
});

promise
  .then(result => {
    console.log(result);
  })
  .catch(error => {
    console.error(error.message); // 'La promesa ha fallado'
  });
```

3. `finally`: Este m√©todo recibe un callback como argumento que se ejecutar√° independientemente de si la promesa se resuelve o se rechaza.

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('La promesa se ha resuelto');
  }, 1000);
});

promise
  .then(result => {
    console.log(result); // 'La promesa se ha resuelto'
  })
  .catch(error => {
    console.error(error);
  })
  .finally(() => {
    console.log('Se ha ejecutado el bloque finally');
  });
```

4. `race`: Este m√©todo recibe un array de promesas, y devuelve una nueva promesa que se resolver√° cuando la primera promesa del array sea resuelta o rechazada.

```js
const promise1 = new Promise(resolve => {
  setTimeout(() => {
    resolve('La promesa 1 se ha resuelto');
  }, 1000);
});

const promise2 = new Promise(resolve => {
  setTimeout(() => {
    resolve('La promesa 2 se ha resuelto');
  }, 2000);
});

Promise.race([promise1, promise2])
  .then(result => {
    console.log(result); // 'La promesa 1 se ha resuelto'
  })
  .catch(error => {
    console.error(error);
  });
```

5. `resolve`: Este m√©todo permite crear una promesa resuelta con un valor determinado.

```js
const promise = Promise.resolve('La promesa se ha resuelto');
```

6. `reject`: Este m√©todo permite crear una promesa rechazada con una raz√≥n determinada.

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('La promesa ha fallado'));
  }, 1000);
});

promise.then(result => {
  console.log(result);
})
.catch(error => {
  console.error(error);
  /*
  Error: La promesa ha fallado
  */
});
```
En este ejemplo, creamos una promesa que se rechazar√° despu√©s de 1 segundo con un mensaje de error. La promesa se rechaza, y la funci√≥n `catch` es invocada para manejar el error.

7. `all`: Este m√©todo recibe un array de promesas, y devuelve una nueva promesa que se resolver√° cuando todas las promesas del array hayan sido resueltas.

```js
const promise1 = new Promise(resolve => {
  setTimeout(() => {
    resolve('La promesa 1 se ha resuelto');
  }, 1000);
});

const promise2 = new Promise(resolve => {
  setTimeout(() => {
    resolve('La promesa 2 se ha resuelto');
  }, 2000);
});

Promise.all([promise1, promise2])
  .then(results => {
    console.log(results); // ['La promesa 1 se ha resuelto', 'La promesa 2 se ha resuelto']
  })
  .catch(error => {
    console.error(error);
  });
```

8. `allSetlled`: El m√©todo allSettled es un m√©todo est√°tico que permite esperar a que todas las promesas se resuelvan o fallen antes de continuar con el siguiente paso. 
A diferencia de `Promise.all`, este devuelve una sola promesa que se resuelve cuando todas las promesas han sido resueltas. 
`allSettled` devuelve una promesa que se resuelve con un array de objetos que describen el estado de cada una de las promesas.

```js
const promise1 = new Promise(resolve => {
  setTimeout(() => {
    resolve({ status: 'fulfilled', value: 'La promesa 1 se ha resuelto' });
  }, 1000);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('La promesa 2 ha fallado'));
  }, 2000);
});

Promise.allSettled([promise1, promise2])
  .then(results => {
    console.log(results);
    /*
    [
      { status: 'fulfilled', value: 'La promesa 1 se ha resuelto' },
      { status: 'rejected', reason: Error: La promesa 2 ha fallado }
    ]
    */
  })
  .catch(error => {
    console.error(error);
  });
```

En este ejemplo, promise1 se resuelve correctamente y promise2 falla. 
El m√©todo `allSettled` espera a que ambas promesas se resuelvan o fallen antes de resolverse con un array que describe el estado de cada una de las promesas.