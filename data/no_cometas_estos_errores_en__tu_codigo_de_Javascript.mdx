---
title: 'No cometas estos errores en tu cÃ³digo de JavaScript âŒ'
date: '2023-01-20'
imgTitle: 'javascript.png'
description: 'Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en JavaScript. AquÃ­ te las enseÃ±o.'
readingTime: '3:00 min'
imageFrontPage: 'https://res.cloudinary.com/dyuj1zglt/image/upload/v1675727354/publicaciones%20del%20blog/thqsvinr3eayxjsywycj.png'
---

![banner](https://res.cloudinary.com/dyuj1zglt/image/upload/v1675727354/publicaciones%20del%20blog/thqsvinr3eayxjsywycj.png)

Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en **JavaScript**.

PodrÃ­amos decir que no son errores exactamente, si no estÃ¡ndares que se tienen a la hora de programar
en este lenguaje.

Esto con el fin de que nuestro cÃ³digo sea mucho mÃ¡s legible, y se pueda entender mejor. Y en ocasiones
pueden funcionar para mejorar nuestro rendimiento en la pÃ¡gina.

Recordemos que muchas veces no somo los **unicos** que tenemos que entender nuestro cÃ³digo. Ya que si trabajas en una empresa,
o bien buscas empleo, es importante tener en cuenta estos factores para demostrar que eres ordenado con tu cÃ³digo, y los demÃ¡s
puedan entenderlo mucho mejor. ğŸ‘¨â€ğŸ’»

## 1Â° Caso: Condiciones redondantes 


No debemos de tener condiciones las cuales si dan **true**, devuelve **true**.

Como se muestra en el siguiente caso. ğŸ‘‡

âŒ
```js
const num1 = 10;
const num2 = 5;

const validacionEntreNumeros = ( num1, num2 ) => {
    if( num1 > num2 ){
        return true;
    }else {
        return false;
    }
}
```

O el mismo caso, pero usando ternarias.

âŒ
```js
const num1 = 10;
const num2 = 5;

const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2 
    ? true 
    : false;
}
```

Por lo que, en un caso como este, es recomendable devolver directamente la condiciÃ³n.

âœ…
```js
const num1 = 10;
const num2 = 5;

const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2;
}
```

Mucho mÃ¡s limpio, **verdad?**

## 2Â° Caso: No utilices `filter`, ni un `bucle` para hacer esto. 

Si tenemos el siguiente array de objetos. ğŸ‘‡

```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
```

Y queremos buscar si alguna de las personas de los objetos es mayor de edad. Donde en caso de que sÃ­ haya, devolverÃ¡ **true**

Posiblemente te verÃ­as tentado a usar el mÃ©todo `filter`. 

De esta manera. ğŸ‘‡

âŒ
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]

Boolean(personas.filter(persona => {
    return persona.age >= 18;
})[0])
```

Esta manera es **horrible**, ya que debemos acceder a la primera posiciÃ³n, y ademÃ¡s de eso tenemos que convertir todo en un Booleano.

Otra forma **errÃ³nea** es utilizando algÃºn bucle, como lo serÃ­a un `forEach`, `while`, o `for`. 

Como el siguiente ejemplo. ğŸ‘‡


âŒ
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]

let found = false;

personas.forEach(persona => {
    if( !found ) {
        found = persona.age >= 18;
    }
})
```

Esto no es correcto, ya que lo que harÃ¡ es recorrer todos los objetos **idenpendientemente** de si lo a encontrado ya.ğŸ¤¦â€â™‚ï¸

Por lo que, en su lugar, debemos utilizar el mÃ©todo `some`.

De esta manera. ğŸ‘‡

âœ…
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]

personas.some((persona) => {
    return persona.age >= 18;
})
```

Esta es la mejora forma de hacerlo, ya que el mÃ©todo `some` devolverÃ¡ **true** al primer elemento que cumpla la condiciÃ³n.ğŸ‘Œ

## 3Â° Caso: Usar `var` en vez de `let` y `const`

Hoy en dÃ­a no es recomendable definir variables con la palabra reservada `var`. Ya que este nos puede generar problemas en nuestro cÃ³digo.
Y uno de los principales problemas de este es que no nos da error al redeclarar una variable. Lo cuÃ¡l es muy peligroso para nuestras aplicaciones.

Un ejemplo de este probleba es el siguiente:
```js
var valor = 1;
console.log(valor) // 1

var valor = 'Armando'
console.log(valor); //Armando

var valor = true;
console.log(valor); // true
```

Otro caso un poco mÃ¡s claro es el siguiente:

âŒ Usando `var`. ğŸ‘‡

```js
var name = 'Armando'

if (name === 'Armando') {
  var name = 'Guillermo'
}

console.log(name) // 'Guillermo'
```

âœ… Usando `let` y `const`. ğŸ‘‡

```js
const name = 'Armando'

if (name === 'Armando') {
  let name = 'Guillermo'
}

console.log(Armando) // 'Armando'
```

En conclusiÃ³n, siempre trata en la medida de los posible hacer uso de las palabras reservadas `let` y `const` para declarar variables en tÃº cÃ³digo.
Te ahorrarÃ¡ muchos problemas. ğŸ˜‰

## 4Â° Caso: Usar `==` en vez de `===` para comparar valores.

El operador `==` no es recomendable utilizarlo para comparar valores, ya que este **NO** compara si las variables son de diferente tipo.
A diferencia del operador `===` que si compara tanto el valor como el tipo de los valores que se estÃ¡n comparando.

âŒ 
```js
const string == '21'
const number == 21

string == number; // true
```

âœ… 
```js
const string = '21'
const number = 21

string === number; // false
```