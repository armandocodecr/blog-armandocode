---
title: 'No cometas estos errores en tu cÃ³digo de JavaScript'
date: '2023-01-13'
imgTitle: 'javascript.png'
description: 'Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en JavaScript. AquÃ­ te las enseÃ±o.âœ'
---

Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en **JavaScript**.

PodrÃ­amos decir que no son errores exactamente, si no estÃ¡ndares que se tienen a la hora de programar
en este lenguaje.

Esto con el fin de que nuestro cÃ³digo sea mucho mÃ¡s legible, y se pueda entender mejor. Y en ocasiones
pueden funcionar para mejorar nuestro rendimiento en la pÃ¡gina.

Recordemos que muchas veces no somo los **unicos** que tenemos que entender nuestro cÃ³digo. Ya que si trabajas en una empresa,
o bien buscas empleo, es importante tener en cuenta estos factores para demostrar que eres ordenado con tu cÃ³digo, y los demÃ¡s
puedan entenderlo mucho mejor. ğŸ‘¨â€ğŸ’»

## 1Â° Caso: Condiciones redondantes 


No debemos de tener condiciones las cuales si dan **true**, devuelve **true**.

Como se muestra en el siguiente caso. ğŸ‘‡

âŒ
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    if( num1 > num2 ){
        return true;
    }else {
        return false;
    }
}
```

O el mismo caso, pero usando ternarias.

âŒ
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2 
    ? true 
    : false;
}
```

Por lo que, en un caso como este, es recomendable devolver directamente la condiciÃ³n.

âœ…
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2;
}
```

Mucho mÃ¡s limpio, **verdad?**

## 2Â° Caso: No utilices `filter`, ni un `bucle` para hacer esto. 

Si tenemos el siguiente array de objetos. ğŸ‘‡

```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
```

Y queremos buscar si alguna de las personas de los objetos es mayor de edad. Donde en caso de que sÃ­ haya, devolverÃ¡ **true**

Posiblemente te verÃ­as tentado a usar el mÃ©todo `filter`. 

De esta manera. ğŸ‘‡

âŒ
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
Boolean(personas.filter(persona => {
    return persona.age >= 18;
})[0])
```

Esta manera es **horrible**, ya que debemos acceder a la primera posiciÃ³n, y ademÃ¡s de eso tenemos que convertir todo en un Booleano.

Otra forma **errÃ³nea** es utilizando algÃºn bucle, como lo serÃ­a un `forEach`, `while`, o `for`. 

Como el siguiente ejemplo. ğŸ‘‡


âŒ
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
let found = false;
personas.forEach(persona => {
    if( !found ) {
        found = persona.age >= 18;
    }
})
```

Esto no es correcto, ya que lo que harÃ¡ es recorrer todos los objetos **idenpendientemente** de si lo a encontrado ya.ğŸ¤¦â€â™‚ï¸

Por lo que, en su lugar, debemos utilizar el mÃ©todo `some`.

De esta manera. ğŸ‘‡

âœ…
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
personas.some((persona) => {
    return persona.age >= 18;
})
```

Esta es la mejora forma de hacerlo, ya que el mÃ©todo `some` devolverÃ¡ **true** al primer elemento que cumpla la condiciÃ³n.ğŸ‘Œ